/******************************************************************************
 Classifier Main File
  
 Date created: 25 April 2011
 Written by:   Feng Xie - Modified by Geoff Lee
 
 This classifier program is a function that creates a genertic program that is able to
 identify the classification of a string of float training data, based on prior classifications
 being made by the user. Using the classifier program, the user is able to test the program on
 unclassified data to determine it's classification.
 
 In our example, image pixel data is used to determine if a section of an image was positive or negative.
 Using a training set of already classified images, a program can be generated that classifies unclassified
 windows of pixel data as positive or negative. 
 
 The program can be used for any data classification, as long as the CSV data file follows the following header:
 
	id, attribute01, attribute02, ..., attributeN, class
	
 Where id is an id string, and class is the classification. For training files the class column must be '?'.
 Data rows must be a consistent size for the program to classify it correctly.
 
 The Classifier takes from 1 to 6 arguments:
 		?> classifier [-C Config.txt] [-T Training.csv] [-E Testing.csv] [-P Population.gen] 
				[-p populationMember] [-I Image.png] [-W Window Size]  
		-C - Configuration file to set evolution values. 
		-T - A training file. 
		-E - A testing file, requires Population file to be included, unless training is run at the same time.
		-P - Population file (generated by training). Can be used in conjuntion with training to seed the initial
		population.
 Additional Image operators:
		-p - Population member to use from the -P Population file. (useful for multiobjective tasks)
		-I - Testing image file.
		-W - Testing image window size.
		-Th - Threshold of the image scanned

 The Image testing is specific to a problem we were analysing, however is not necessary for other data sets.	
		
 The config file has a number of additional options including:
	Evolution settings
	Dynamic depth limitaion / Tarpein depth limitation
	Standard selection/dynamic range selection
	Multi Objective serach based on false negatives and false positives
	
	See the config file for a more functionality.
		
		
******************************************************************************/

#include "main.h"

int main (int argc, char* argv[])
{
	int THRESHOLD = 0;	// Value for image thresholding, otherwise unused
	run_time = time(NULL); // Starts a timer for testing purposes
	
	GPConfig symConfig;
	symConfig.numObjectives = 2; //Used for EMO, sets the number of objectives stored. 

	char trainingFile[FILENAME_SIZE];
	char testingFile[FILENAME_SIZE];
	char populationFile[FILENAME_SIZE];
    
    int processID = 0; // for MPI processing, sets the processor ID to 0;

#ifdef MPI_ENABLED	//MPI initialization if -D MPI_ENABLED is true
	int processSize = 0; 
    MPI_Init (&argc, &argv);
    MPI_Comm_size(MPI_COMM_WORLD, &processSize);
    MPI_Comm_rank(MPI_COMM_WORLD, &processID);
#endif

	if (argc<3)
	{
	  if (processID == 0)
	    {
		cout << "\nError: RMITGP requires minimum 2 arguments. " << endl;
		cout << "\nclassifier [-C Config.txt] [-T Training.csv] [-E Testing.csv] [-P Population.gen] required" << endl;
		cout << "\t-C - Configuration file to set evolution values. " << endl;
		cout << "\t-T - Training file. " << endl;
		cout << "\t-E - Testing file, requires Population file to be included. " << endl;
		cout << "\t-P - Initial population file." << endl;
		cout << "OPTIONAL:" << endl;
		cout << "\t-p - Population member to use from -P Population file." << endl;
		cout << "\t-I - Testing image file." << endl;
		cout << "\t-W - Testing image window size." << endl;
		cout << "\t-S - Testing image step size." << endl;
	    }
	  return 0;
	} 
	
	for(int i = 1;i+1<argc;i+=2)
	{
		if(strcmp(argv[i],"-C")==0)
		{
			loadConfig(argv[i+1]);
		}	
		else if	(strcmp(argv[i],"-T")==0)
		{
			strcpy(trainingFile, argv[i+1]); 
			TRAINING = 1;
		}	
		else if	(strcmp(argv[i],"-E")==0)
		{
			strcpy(testingFile, argv[i+1]); 
			TESTING = 1;
		}	
		else if	(strcmp(argv[i],"-P")==0)
		{
			strcpy(populationFile, argv[i+1]);
			POPULATION = 1;
		}
		else if	(strcmp(argv[i],"-p")==0)
		{
			SELECTED_POP = atoi(argv[i+1]);	
		}
		else if	(strcmp(argv[i],"-I")==0)
		{
			strcpy(testingFile, argv[i+1]);
			IMAGE_TESTING = 1;
		}
		else if	(strcmp(argv[i],"-W")==0)
		{
			WINDOW_SIZE = atoi(argv[i+1]);
		}
		else if	(strcmp(argv[i],"-S")==0)
		{
			STEP_SIZE = atoi(argv[i+1]);
		}	
		else if	(strcmp(argv[i],"-Th")==0)
		{
			THRESHOLD = atoi(argv[i+1]);
		}				
		else
		{
			cout << "\nArguements [-C Config.txt] [-T Training.csv] [-E Testing.csv] [-P Population.gen] required." << endl;
			return 0;
		}		
	}
	
	// INITIAL FILE LOADING (Used to determine the number of attributes (imageSize) in the CSV
	if (TESTING == 1 || TRAINING == 1)
	{
		FILE *fi;
		char* tok;
		char linedata[10000];	
		try {
			if (TRAINING == 1)
				{fi = fopen(trainingFile, "r");}
			else if (TESTING == 1)
				{fi = fopen(testingFile, "r");}
			if (fi == NULL)
				throw string("main() Error, can not open file");
		} 
		catch (string s)
		{
			cerr << s <<endl;
			exit(-1);
		}
		imageSize = -1;
		fgets(linedata,10000-2,fi); // Skip line with variable names
		tok=strtok(linedata,", \n\r");
		while (tok!=NULL)
		{
			imageSize++;
			tok=strtok(NULL,", \n\r");
		}	
		cout<<"Image Size: "<< imageSize << endl;
		fclose(fi);
	}
	else
	{
		imageSize = WINDOW_SIZE * WINDOW_SIZE;
		if (IMAGE_TESTING == 0)
		{
			cout<<"No training or testing files given"<<endl;
			return 0;
		}
	}
	// END OF FILE LOADING
	
	// For MPI, create small population sizes for the slave processors (only one program is processed at a time)
	#ifdef MPI_ENABLED
	if(processID != 0)
	{POP_SIZE = 2; INITIAL_POP_SIZE = 2;}
	#endif
	//Declare a population, giving the size and a log file name

	if (INITIAL_POP_SIZE == 0) INITIAL_POP_SIZE = POP_SIZE;
	Population SINGLEpop(POP_SIZE, INITIAL_POP_SIZE, "run-log.txt", &symConfig);
	EMOPopulation EMOpop(POP_SIZE, INITIAL_POP_SIZE, "EMOrun-log.txt", &symConfig);
	Population *pop;
	if (EMO)
	{
		symConfig.numObjectives = 2;
		pop = &EMOpop;
		EMOpop.setMutationProbability(MUTATION_PROBABILITY);
	}
	else
	{
		pop = &SINGLEpop;
	}

	//Set the rates of mutation etc 
	pop->setMutationRate(MUTATION_RATE);
	pop->setCrossoverRate(CROSSOVER_RATE);
	pop->setElitismRate(ELITISM_RATE);	
		
	//Set the decimation event if available
	if (INITIAL_POP_SIZE != POP_SIZE)
	{
		pop->setNumGenerationBeforeDecimation(DECIMATION_EVENT);	
	}
		
	//Initialisation of the GPConfig class
	symConfig.defaultInit();
	
	//Add the terminals we need: 
	//symConfig.termSet.addNodeToSet(ReturnIndex::TYPENUM, RandIndex::generate);
	//symConfig.termSet.addNodeToSet(ReturnInt::TYPENUM, RandInt::generate);/////
	symConfig.termSet.addNodeToSet(ReturnDouble::TYPENUM, RandDouble::generate);
	//symConfig.termSet.addNodeToSet(ReturnTOperation::TYPENUM, RandTOperation::generate);
	//symConfig.termSet.addNodeToSet(ReturnTIndex::TYPENUM, RandTIndex::generate);
	//symConfig.termSet.addNodeToSet(ReturnSOperation::TYPENUM, RandSOperation::generate);
	//symConfig.termSet.addNodeToSet(ReturnVIndex::TYPENUM, RandVIndex::generate);
	symConfig.termSet.addNodeToSet(ReturnDouble::TYPENUM, Attribute::generate);
	//symConfig.termSet.addNodeToSet(ReturnCoordinate::TYPENUM, Coordinate::generate);
	//symConfig.termSet.addNodeToSet(ReturnRect::TYPENUM, Rect::generate);
	//symConfig.termSet.addNodeToSet(ReturnDouble::TYPENUM, TempTerminalC::generate);
	//symConfig.termSet.addNodeToSet(ReturnDouble::TYPENUM, TempTerminalD::generate);

	//Add the functions we need:
	//symConfig.funcSet.addNodeToSet(ReturnDouble::TYPENUM, ReadD::generate);
	//symConfig.funcSet.addNodeToSet(ReturnDouble::TYPENUM, TempDFunctionP::generate);
	//symConfig.funcSet.addNodeToSet(ReturnDouble::TYPENUM, TempDFunctionD::generate);
	//symConfig.funcSet.addNodeToSet(ReturnDouble::TYPENUM, Diff::generate);
	//symConfig.funcSet.addNodeToSet(ReturnDouble::TYPENUM, AOI::generate);
	//symConfig.funcSet.addNodeToSet(ReturnDouble::TYPENUM, VOI::generate);
	//symConfig.funcSet.addNodeToSet(ReturnBoolean::TYPENUM, And::generate);
	//symConfig.funcSet.addNodeToSet(ReturnBoolean::TYPENUM, Xor::generate);
	//symConfig.funcSet.addNodeToSet(ReturnBoolean::TYPENUM, Or::generate);
	//symConfig.funcSet.addNodeToSet(ReturnBoolean::TYPENUM, Not::generate);
	//symConfig.funcSet.addNodeToSet(ReturnDouble::TYPENUM, StandDeviation::generate);
	//symConfig.funcSet.addNodeToSet(ReturnDouble::TYPENUM, AveragePixel::generate);
	//symConfig.funcSet.addNodeToSet(ReturnDouble::TYPENUM, MaxPixel::generate);//
	//symConfig.funcSet.addNodeToSet(ReturnDouble::TYPENUM, MinPixel::generate);//
	symConfig.funcSet.addNodeToSet(ReturnDouble::TYPENUM, PlusDouble::generate);
	symConfig.funcSet.addNodeToSet(ReturnDouble::TYPENUM, MinusDouble::generate);
	symConfig.funcSet.addNodeToSet(ReturnDouble::TYPENUM, MultDouble::generate);
	symConfig.funcSet.addNodeToSet(ReturnDouble::TYPENUM, DivideDouble::generate);
	//symConfig.funcSet.addNodeToSet(ReturnDouble::TYPENUM, AbsoluteDouble::generate);
	//symConfig.funcSet.addNodeToSet(ReturnDouble::TYPENUM, If::generate);
	//symConfig.funcSet.addNodeToSet(ReturnBoolean::TYPENUM, LessThan::generate);
	//symConfig.funcSet.addNodeToSet(ReturnBoolean::TYPENUM, GreaterThan::generate);
	//symConfig.funcSet.addNodeToSet(ReturnBoolean::TYPENUM, Equal::generate);
	//symConfig.funcSet.addNodeToSet(ReturnBoolean::TYPENUM, Between::generate);
	
	//Set the return type for our programs
	pop->setReturnType(ReturnDouble::TYPENUM);
	
	//Set the depth limit for the system
	symConfig.maxDepth = MAXDEPTH;
	symConfig.minDepth = MINDEPTH;
	
	//Set the depth limit for the population
	pop->setDepthLimit(symConfig.maxDepth);
	pop->setMinDepth(symConfig.minDepth);

	symConfig.programGenerator = new ProgramGenerator(&symConfig);
	
	//Set the fitness class to be used
	symConfig.fitnessObject = new ClassificationFitness(&symConfig);
	
	//Initialise the fitness 
	symConfig.fitnessObject->initFitness();
	pop->setLogFrequency(1);
#ifdef UNIX
    pop->compressGenerationFiles(true);
#endif

#ifdef MPI_ENABLED // MPI setup/allocation of slave processors
    if(processID != 0)
    {
       loadData(trainingFile);
		pop->generateInitialPopulation();
		cout<<"Slave Generation Populated"<<endl;
		ClassificationFitness * classPointer = dynamic_cast<ClassificationFitness*>(symConfig.fitnessObject);
		classPointer->slaveProcess(pop->getIndividual(0));
		//cout<<"Slave Generation Finalised"<<endl;
		MPI_Finalize();
		return 0;
    }
#endif
	
	if (!POPULATION) // No pop file given, random generation of inital programs
	{
		if(!EMO)
		{
			pop->generateInitialPopulation();
		}
		else
		{
			EMOpop.generateInitialPopulation();
		}
	}
	else //Seeding the Classifier with a population group from a file
	{
		pop->readFromFile(populationFile);
	}
	cout << "Population generated." << endl;
	//Write out the population every 20 generations

	if (TRAINING) //Training, if a Training file was selected
	{
		cerr << "\nTRAINING:" <<endl;
        loadData(trainingFile);
		string programString, range;
		
		bool evolutionResult = false;
		
		if (EMO)
			{evolutionResult = EMOpop.evolve(EVOLVE);}
		else
			{evolutionResult = SINGLEpop.evolve(EVOLVE);}
					
		if (evolutionResult)
		{
			cout << "Found perfect solution." << endl;
		}
		else
		{
			cout << "Didn't find perfect solution." << endl;
		}
		
		//Printing results to console::
		pop->getBest()->print(programString);
		cout << "Best program:" << endl;
		cout << "Fitness: " << (pop->getBest())->getFitness() << endl;
		cout  << programString << endl;
		if (DYNAMIC_SELECTION)
		{
			(pop->getBest())->printRange(range);
			cout << "Range: " << endl << range << endl;
		}
		if (EMO) // If EMO is selected, will create a data file for easy EMO graphing
		{
			remove("EMO_graph_data.txt");
			//pop->sortPopulation();
			logFile.open("EMO_graph_data.txt", ios::app);
			if (logFile.bad())
			{
				throw string("Population::Population() Error cannot open log file");
			}
			logFile << "#Individual A B previousA previousB" <<endl;    
			for(int i = 0; i < POP_SIZE; i++) {
				logFile<<i<<" "<<pop->getIndividual(i)->getObjectiveValue(0) << " " << pop->getIndividual(i)->getObjectiveValue(1)<<endl;
			}
			logFile << endl;
			logFile.close();
		}					
		cout  << "TRAINING COMPLETE" << endl;
	}

	if (TESTING || IMAGE_TESTING) //If either testing or image processing is active, prefrom this task
	{ 
		cout  << "\nTESTING:\n" << endl;
		if (IMAGE_TESTING == 0)
		{		
			loadData(testingFile);
		}
		else 
		{
			loadImage(testingFile);
		}
		cout << "Data has been read successfully" << endl;
		
		char * outputClasses;
		
		if (DYNAMIC_SELECTION)
		{
			outputClasses = dynamic_selection_testing(pop->getIndividual(SELECTED_POP));
		}
		else
		{
			outputClasses = normal_testing(pop->getIndividual(SELECTED_POP));
		}
		
		// Printing Test Results:
		string programString, range;
		(pop->getIndividual(SELECTED_POP))->print(programString);
		cout << "\nBest program:" << endl;
		cout << "Fitness: " << (pop->getIndividual(SELECTED_POP))->getFitness() << endl;
		cout << programString << endl;
		if (DYNAMIC_SELECTION)
		{
			(pop->getIndividual(SELECTED_POP))->printRange(range);	
			cout << "Range: " << endl << range << endl;
		}

		// Log File creation
		logFile.open("test-log.txt", ios::app);
		if (logFile.bad())
		{
			throw string("Population::Population() Error cannot open log file");
		}
		logFile << "*****************************************\n"    
		<< "Program "<< programString << endl
		<< "Output " << outputClasses << endl
		<< "Correct ";
		for(int i = 0; i < nOfImages; i++) 
		{
			logFile << dataClassification[i];
		}
		logFile << endl;
		logFile.close();

		// Error Reporting
		if (dataClassification[0] != '?')
		{
			cout << "\nError reporting:"<<endl;
			cout << "Expected outcome:\n";
			for(int i = 0; i < nOfImages; i++) 
			{
				cout << dataClassification[i];
			}
			cout << "\nFinal outcome:\n"<<outputClasses<<endl;
			cout << "False Negatives: ";
			for(int i = 0; i < nOfImages; i++) 
			{
				if ((dataClassification[i]!=outputClasses[i])&&dataClassification[i]=='T')
						cout<<i<<" ";
			}		
			cout << "\nFalse Positives: ";
			for(int i = 0; i < nOfImages; i++) 
			{
				if ((dataClassification[i]!=outputClasses[i])&&dataClassification[i]=='F')
						cout<<i<<" ";
			}		
		}
		//CSV Writing - Result mimics WeKa toolset results, for comparitive results
		char resultsFile[FILENAME_SIZE];
		FILE *csv;
		char linedata[200];
		strcpy(resultsFile, testingFile);
        strcat(resultsFile, "_results");
		try
		{
		  csv = fopen(resultsFile, "w");
		}
		catch(char * error_report)
		{
		   cout<<"logfile cannot be opened!";
		}
	    cout<<resultsFile;
		fputs(linedata,csv);
		for (int i = 0;i<nOfImages;i++)
		{
			strcpy(linedata,"");
			int actualCode = 1;
			int predictedCode = 1;
			if(dataClassification[i] == 'F')
				actualCode = 2;
			if (outputClasses[i] == 'F')
				 predictedCode = 2;
			sprintf(linedata,"\t%d\t%d:%c\t%d:%c\t1\n",i+1,
				actualCode,dataClassification[i],
				predictedCode, outputClasses[i]);
			fputs(linedata,csv);
		}
		fclose(csv);
		
		if(IMAGE_TESTING) // Special Image processing/Heatmap generation
		{
			cout << "Image Processing\n";
			Vector2D grid;
			grid.resize(imageWidth);

			for (Vector2D::iterator i = grid.begin(); i != grid.end(); ++i)
			{
				i->resize(imageWidth);
			 }	
			unsigned int y = 0;
			unsigned int x = 0;
			for(int line = 0;line < nOfImages; line++)
			{
				// mark the window
				unsigned int i = 0;
				unsigned int j = 0;
				for (i = y; i < (y+WINDOW_SIZE); ++i)
				{
				for (j = x; j < (x+WINDOW_SIZE); ++j)
				{
				  if (outputClasses[line] == 'T')
					  grid[i][j].incrementPos();
				  else
					  grid[i][j].incrementNeg();
				}
				}
				// loop back when necessary
				if (x >= imageWidth-WINDOW_SIZE)
				{
					x = 0;
					y += 1;
				}
				else
				{
					x += 1;
				}	
			}
			double max = findMax(grid);
			Data::threshold = max*(THRESHOLD/100.0);
			outputHeatmap(grid, imageWidth, max, testingFile);
			outputHeatmapRGB3(grid, imageWidth, testingFile, WINDOW_SIZE, 1);
		}
	  
	}
#ifdef MPI_ENABLED	// Close off MPI systems
    for (int i = 1; i<processSize;i++)
    {
		char message[10000] = "-1 end of file";
		MPI_Send(&message, 10000, MPI_CHAR,i, 1, MPI_COMM_WORLD);
    }		
	cout << "Final Runtime = " << (time(NULL)-run_time)<< endl;
	MPI_Finalize();
#endif
	symConfig.cleanUpObjects();
	free(dataClassification);
	
	return 0;
}



int loadConfig(char configFile[FILENAME_SIZE]) // To load in configuration file parameters. Add as necessary.
{
	cout<<"Loading configuration: "<< configFile <<endl;
	FILE *fi;
	char tmp[FILENAME_SIZE];
	char var[FILENAME_SIZE];
	char arg[FILENAME_SIZE];

	//else strcpy(inputFile, "input.dat");
	try {
		fi = fopen(configFile, "r");
		if (fi == NULL)
			throw string("main() Error, can not open file");
	} 
	catch (string s)
	{
		cerr << s <<endl;
		exit(-1);
	}
	while (fgets(tmp,FILENAME_SIZE,fi) != NULL) 
	{
		if (tmp[0] != '#')
		{
			sscanf (tmp,"%s %s",var,arg);
			if (strcmp(var,"GENERATIONS:" )==0)
				{EVOLVE = atoi(arg);}	
			if (strcmp(var,"POP_SIZE:" )==0)
				{POP_SIZE = atoi(arg);}	
			if (strcmp(var,"INITIAL_POP_SIZE:" )==0)
				{INITIAL_POP_SIZE = atoi(arg);}	
			if (strcmp(var,"DECIMATION_EVENT:" )==0)
				{DECIMATION_EVENT = atoi(arg);}	
			if (strcmp(var,"MAXDEPTH:" )==0)
				{MAXDEPTH = atoi(arg);}	
			if (strcmp(var,"MINDEPTH:" )==0)
				{MINDEPTH = atoi(arg);}	
			if (strcmp(var,"MUTATION_RATE:" )==0)
				{MUTATION_RATE = atof(arg);}	
			if (strcmp(var,"CROSSOVER_RATE:" )==0)
				{CROSSOVER_RATE = atof(arg);}	
			if (strcmp(var,"ELITISM_RATE:" )==0)
				{ELITISM_RATE = atof(arg);}	
			if (strcmp(var,"DYNAMIC_SELECTION:" )==0)
				{DYNAMIC_SELECTION = atoi(arg);}	
			if (strcmp(var,"DDL:" )==0)
				{DDL = atoi(arg);}	
			if (strcmp(var,"TARPEIAN:" )==0)
				{TARPEIAN = atoi(arg);}	
			if (strcmp(var,"EMO:" )==0)
				{EMO = atoi(arg);}				
			if (strcmp(var,"MUTATION_PROBABILITY:" )==0)
				{MUTATION_PROBABILITY = atof(arg);}		
		}
	}
	fclose(fi);
	cout << "Pop Size: " << POP_SIZE << " Initial: "<< INITIAL_POP_SIZE<< " Generations: "<< EVOLVE << " Mutation rates: " << MUTATION_RATE<< " "<<CROSSOVER_RATE<<" "<<ELITISM_RATE << endl;
	if (DYNAMIC_SELECTION)
		cout<<"Dynamic Selection Enabled."<<endl;
	cout << "Configuration data has been loaded successfully." << endl;
	return 0;
}

void loadImage(char dataFile[FILENAME_SIZE]) // loads an PNG file into a 2d pixel array.
{
	int imageColourDepth;
	int tempVal;
	string garbage;
	ifstream infile;
	stringstream ss;
	string lineData = "";
	
	infile.open (dataFile);
	ss << infile.rdbuf();
	ss>>garbage;
	ss >>imageHeight >>imageWidth;
	cout<<"Image Height = "<<imageHeight<<endl;
	cout<<"Image Width = "<<imageWidth<<endl;
	ss >> imageColourDepth;
	int pixelnumber = 0;
	int pixelHeight = 0;
	for(int pixelHeight = 0;pixelHeight<imageHeight;pixelHeight++)
	{
		image_data.push_back(vector<double>());
		pixelnumber = 0;
		do
		{
			ss>>tempVal;	
			image_data[pixelHeight].push_back(((float)tempVal)/imageColourDepth);	
			pixelnumber++;
				
		} while(pixelnumber < imageWidth);
	}
	cout<<"Last pixel = "<<pixelHeight<<" "<<pixelnumber<<endl;
	ss.str("");
	nOfImages = ((imageHeight-WINDOW_SIZE+1)*(imageWidth-WINDOW_SIZE+1));
	/*Initialise the data array of vectors, that would contain the training data,
	 that is, data of all the provided images*/ 
	data.clear();

	dataClassification = (char *) malloc((sizeof(char))*nOfImages); // memory allocation 

	for(int i = 0; i < nOfImages; i++)
	{
		dataClassification[i] = '?';
	}
	infile.close();
	cout << "Data has been read successfully" << endl;
	return;
}


void loadData(char dataFile[FILENAME_SIZE])
{
	FILE *fi;
    char* tok;
    char linedata[10000];	
	int row, lineLimiter;

	try {
		fi = fopen(dataFile, "r");
		if (fi == NULL)
			throw string("main() Error, can not open file");
	} 
	catch (string s)
	{
		cerr << s <<endl;
		exit(-1);
	}
	nOfImages = -1; // Set to -1 instead of 0 because first line is col names
	while (fgets(linedata,10000-2,fi)!=NULL)
		nOfImages++;
	rewind(fi);
	/*Initialise the data array of vectors, that would contain the training data,
	 that is, data of all the provided images*/ 
	data.clear();
	dataClassification = (char *) malloc (sizeof(char)*nOfImages); // memory allocation 
	if (dataClassification == NULL)
		throw string("main() Error, can not allocate memory for dataClassification");
	//cout<<"Data file lines: "<<nOfImages<<endl;	
	fgets(linedata,10000-2,fi); // Skip line with variable names
	row = 0;
	while (fgets(linedata,10000-2,fi)!=NULL)
	{
		lineLimiter = 0;
		tok=strtok(linedata,", \n\r");
		data.push_back(vector<double>());
		while (tok!=NULL && lineLimiter<imageSize)
		{		
			lineLimiter++;
			data[row].push_back(atof(tok));	
			tok=strtok(NULL,", \n\r");
		}
		
		if (tok[0] =='T')dataClassification[row] = 'T';
		if (tok[0] =='F')dataClassification[row] = 'F';
		if (tok[0] =='?')dataClassification[row] = '?';
		row++;
	}		
//	cout<<"Data file lines: "<<row<<endl;
	fclose(fi);
	cout << "Data has been read successfully" << endl;
	return;
}		

void outputHeatmap(Vector2D &grid, unsigned int imageSize, double max, string origFile)
{
   Data::scale = 255;
   Data::max = (max);
   int basenameEnd = origFile.find_last_of(".");
   string basename = origFile.substr(0,basenameEnd);
   basename.append("_heatmap.pgm");
   ofstream output (basename.c_str(), ios_base::trunc);
   output << "P2" << endl;
   output << imageSize << " " << imageSize << endl;
   output << "255" << endl;
   int count = 0;
   
   for (Vector2D::iterator i = grid.begin(); i != grid.end(); ++i)
   {
	cout<<count++<<endl;
      for (vector<Data>::iterator j = i->begin(); j != i->end(); ++j)
      {
         output << (*j) << " ";
      }
      output << endl;
   }

   output.close();
}

double findMax(Vector2D &grid)
{
   double max = 0;
   for (Vector2D::iterator i = grid.begin(); i != grid.end(); ++i)
   {
      for (vector<Data>::iterator j = i->begin(); j != i->end(); ++j)
      {
         if ((j->getPos() - j->getNeg()) > max)
            max = (j->getPos() - j->getNeg());
      }
   }
   return max;    
}

void outputHeatmapRGB3(Vector2D &grid, unsigned int imageSize, string origFile, unsigned int windowSize, unsigned int shiftSize )
{
   int basenameEnd = origFile.find_last_of(".");
   string basename = origFile.substr(0,basenameEnd);
   string red = basename;
   red +=".red";
   string blue = basename;
   blue +=".blu";
   string green= basename;
   green +=".grn";
   ofstream outputR (red.c_str(), ios_base::trunc);
   ofstream outputG (green.c_str(), ios_base::trunc);
   ofstream outputB (blue.c_str(), ios_base::trunc);
   outputR << "P2" << endl;
   outputG << "P2" << endl;
   outputB << "P2" << endl;
   outputR << imageSize << " " << imageSize << endl;
   outputG << imageSize << " " << imageSize << endl;
   outputB << imageSize << " " << imageSize << endl;
   outputR << "255" << endl;
   outputG << "255" << endl;
   outputB << "255" << endl;
   
   vector<int> original;
   ifstream fInput;
   string iLine;
   // open file for reading
   try 
   {
      fInput.open(origFile.c_str());
      if (!(fInput.good()))
      {
         throw string("Could not open csv file ");
      }
   }
   catch (string s)
   {
      cerr << s << origFile << endl;
      exit(-1);
   }
   // go through each line of the results file and mark each window appropriately
   getline(fInput, iLine);
   getline(fInput, iLine);
   getline(fInput, iLine);
   while (getline(fInput, iLine))
   {
      istringstream iss;
      iss.str(iLine);
      char tmp[100];
      while (iss >> tmp)
         original.push_back(atof(tmp));
      iss.clear();
   }   
   
   unsigned int y = 0;
   vector<int>::iterator val = original.begin();
   cout << "ws: " << windowSize << " imageSize: " << imageSize << " ws-is: " << (imageSize-windowSize) << endl;
   for (Vector2D::iterator i = grid.begin() ; i != grid.end(); ++i)
   {
      unsigned int x = 0;
      for (vector<Data>::iterator j = i->begin(); j != i->end(); ++j, ++val)
      {
         if (((x < windowSize) || x > (imageSize-windowSize)) || (y < windowSize || (y > (imageSize-windowSize))))
         {
            outputR << "255 ";   
            outputG << "255 ";   
            outputB << "255 ";   
         }
         else
         {
            outputR << (*val) << " ";
            if ((j->getPos() - j->getNeg()) > Data::threshold)
            {
               outputG << "0 ";
               outputB << "0 ";
            }
            else
            {
               outputG << (*val) << " ";
               outputB << (*val) << " ";
            }
         }
         x++ ;
      }
      outputR << endl;
      outputG << endl;
      outputB << endl;
      y++;
   }
   outputR.close();
   outputG.close();
   outputB.close();

   cout << red << " " << " " << green << " " << blue << " generated." << endl;
}




   
